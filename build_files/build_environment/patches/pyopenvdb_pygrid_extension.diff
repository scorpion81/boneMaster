diff --git a/openvdb/python/pyGrid.h b/openvdb/python/pyGrid.h
index 5bf453c..f071456 100644
--- a/openvdb/python/pyGrid.h
+++ b/openvdb/python/pyGrid.h
@@ -63,10 +63,19 @@
 #include "openvdb/io/Stream.h"
 #include "openvdb/math/Math.h" // for math::isExactlyEqual()
 #include "openvdb/tools/LevelSetSphere.h"
+#include "openvdb/tools/ParticlesToLevelSet.h"
 #include "openvdb/tools/Dense.h"
 #include "openvdb/tools/ChangeBackground.h"
 #include "openvdb/tools/Prune.h"
 #include "openvdb/tools/SignedFloodFill.h"
+#include "openvdb/tools/Filter.h"
+#include "openvdb/tools/Composite.h"
+#include "openvdb/tools/GridTransformer.h"
+#include "openvdb/tools/GridOperators.h"
+#include "openvdb/tree/LeafManager.h"
+#include "openvdb/points/AttributeArray.h"
+#include "openvdb/points/PointDataGrid.h"
+
 #include "pyutil.h"
 #include "pyAccessor.h" // for pyAccessor::AccessorWrap
 #include "pyopenvdb.h"
@@ -78,6 +87,48 @@
 #include <string>
 #include <vector>
 
+#include <tbb/parallel_for.h>
+#include <tbb/atomic.h>
+
+
+#define INVALID_IDX 0xFFFFFFFF
+
+// const uint32_t INVALID_IDX = 0xFFFFFFFF;
+
+// static const Coord COORD_OFFSETS[26] =
+// {
+// 	Coord(1,  0,  0), /// Voxel-face adjacent neghbours
+// 	Coord(-1,  0,  0), /// 0 to 5
+// 	Coord(0,  1,  0),
+// 	Coord(0, -1,  0),
+// 	Coord(0,  0,  1),
+// 	Coord(0,  0, -1),
+// 	Coord(1,  0, -1), /// Voxel-edge adjacent neghbours
+// 	Coord(-1,  0, -1), /// 6 to 17
+// 	Coord(1,  0,  1),
+// 	Coord(-1,  0,  1),
+// 	Coord(1,  1,  0),
+// 	Coord(-1,  1,  0),
+// 	Coord(1, -1,  0),
+// 	Coord(-1, -1,  0),
+// 	Coord(0, -1,  1),
+// 	Coord(0, -1, -1),
+// 	Coord(0,  1,  1),
+// 	Coord(0,  1, -1),
+// 	Coord(-1, -1, -1), /// Voxel-corner adjacent neghbours
+// 	Coord(-1, -1,  1), /// 18 to 25
+// 	Coord(1, -1,  1),
+// 	Coord(1, -1, -1),
+// 	Coord(-1,  1, -1),
+// 	Coord(-1,  1,  1),
+// 	Coord(1,  1,  1),
+// 	Coord(1,  1, -1)
+// };
+
+#define PI 3.141592653589793f
+#define EE 2.718281828459045f
+#define PISQRT 2.5066282746310002f
+
 namespace py = boost::python;
 
 #ifdef __clang__
@@ -232,6 +283,34 @@ extractValueArg(
 }
 
 
+// template<typename GridT, typename MaskT, typename InterruptT>
+// template<size_t Axis>
+// inline typename GridT::ValueType
+// Filter<GridT, MaskT, InterruptT>::AvgI<Axis>::operator()(Coord xyz)
+// {
+// 	// Sampled Gaussian kernel
+// 	ValueType sum = zeroVal<ValueType>();
+// 	float multiplier = 0.f, error = 0.f;
+// 	//float sigma = std::sqrt((float)width / 4.0f);
+// 	// M = C*sqrt(t) + 1
+// 	//int M = (int)(5.0f * sigma + 1.0f);
+// 	int M = width;
+
+// 	Int32 &i = xyz[Axis], j = i + M;
+// 	Int32 center = i;
+
+// 	for (i -= M; i <= j; ++i) {
+// 		// G(x) = 1/sqrt(2*PI)/sigma * e ** -(x**2/(2*sigma**2))
+// 		Int32 x = i - center;
+// 		multiplier = 1.f / PISQRT / sigma * std::pow(EE, -x*x / (2 * sigma*sigma));
+// 		error += multiplier;
+// 		filter_internal::accum(sum, multiplier * acc.getValue(xyz));
+// 	}
+// 	//return static_cast<ValueType>(sum / error);
+// 	return static_cast<ValueType>(sum);
+// }
+
+
 ////////////////////////////////////////
 
 
@@ -313,7 +392,11 @@ setGridName(GridBase::Ptr grid, py::object strObj)
 {
     if (grid) {
         if (!strObj) { // if name is None
+#ifdef WIN32
+			grid->removeMeta("name");
+#else
             grid->removeMeta(GridBase::META_GRID_NAME);
+#endif
         } else {
             const std::string name = pyutil::extractArg<std::string>(
                 strObj, "setName", /*className=*/nullptr, /*argIdx=*/1, "str");
@@ -328,7 +411,11 @@ setGridCreator(GridBase::Ptr grid, py::object strObj)
 {
     if (grid) {
         if (!strObj) { // if name is None
+#ifdef WIN32
+			grid->removeMeta("creator");
+#else
             grid->removeMeta(GridBase::META_GRID_CREATOR);
+#endif
         } else {
             const std::string name = pyutil::extractArg<std::string>(
                 strObj, "setCreator", /*className=*/nullptr, /*argIdx=*/1, "str");
@@ -1390,6 +1477,422 @@ meshToLevelSet(py::object pointsObj, py::object trianglesObj, py::object quadsOb
 }
 
 
+// amb: Extending OpenVDB Python functionality
+
+
+template<typename GridType>
+inline openvdb::FloatGrid::Ptr
+pointsToLevelSet(
+	py::object pointsObj,
+	py::object xformObj,
+	py::object radiusObj)
+{
+	class ParticleList {
+	private:
+		std::vector<Vec3s> *points;
+		openvdb::Real psize;
+	public:
+		ParticleList(std::vector<Vec3s> *p) {
+			points = p;
+			psize = 0.0f;
+		}
+
+		using PosType = openvdb::Vec3R;
+		
+        // Return the total number of particles in list.
+		// Always required!
+		size_t size() const {
+			return points->size();
+		}
+
+		// Get the world space position of the nth particle.
+		// Required by ParticledToLevelSet::rasterizeSphere(*this,radius).
+		void getPos(size_t n, Vec3R& xyz) const {
+			const Vec3s p = points->at(n);
+			xyz[0] = p[0], xyz[1] = p[1], xyz[2] = p[2];
+		}
+
+		// Get the world space position and radius of the nth particle.
+		// Required by ParticledToLevelSet::rasterizeSphere(*this).
+		void getPosRad(size_t n, Vec3R& xyz, Real& rad) const {
+			const Vec3s p = points->at(n);
+			xyz[0] = p[0], xyz[1] = p[1], xyz[2] = p[2];
+			rad = psize;
+		}
+		// Get the world space position, radius and velocity of the nth particle.
+		// Required by ParticledToLevelSet::rasterizeSphere(*this,radius).
+		void getPosRadVel(size_t n, Vec3R& xyz, Real& rad, Vec3R& vel) const {
+			const Vec3s p = points->at(n);
+			xyz[0] = p[0], xyz[1] = p[1], xyz[2] = p[2];
+			rad = psize;
+		}
+
+		// Get the attribute of the nth particle. AttributeType is user-defined!
+		// Only required if attribute transfer is enabled in ParticlesToLevelSet.
+		void getAtt(size_t n, openvdb::Int32& att) const {
+			att = 0;
+		};
+	};
+
+	struct Local {
+		// Return the name of the Python grid method (for use in error messages).
+		static const char* methodName() { return "createLevelSetFromPoints"; }
+
+		// Raise a Python exception if the given NumPy array does not have dimensions M x N
+		// or does not have an integer or floating-point data type.
+		static void validate2DNumPyArray(NumPyArrayType arrayObj,
+			const size_t N, const char* desiredType)
+		{
+			const auto dims = arrayDimensions(arrayObj);
+
+			bool wrongArrayType = false;
+			// Check array dimensions.
+			if (dims.size() != 2 || dims[1] != N) {
+				wrongArrayType = true;
+			}
+			else {
+				// Check array data type.
+				switch (arrayTypeId(arrayObj)) {
+				case DtId::FLOAT: case DtId::DOUBLE: //case DtId::HALF:
+				case DtId::INT16: case DtId::INT32: case DtId::INT64:
+				case DtId::UINT32: case DtId::UINT64: break;
+				default: wrongArrayType = true; break;
+				}
+			}
+			if (wrongArrayType) {
+				// Generate an error message and raise a Python TypeError.
+				std::ostringstream os;
+				os << "expected N x 3 numpy.ndarray of " << desiredType << ", found ";
+				switch (dims.size()) {
+				case 0: os << "zero-dimensional"; break;
+				case 1: os << "one-dimensional"; break;
+				default:
+					os << dims[0];
+					for (size_t i = 1; i < dims.size(); ++i) { os << " x " << dims[i]; }
+					break;
+				}
+				os << " " << arrayTypeName(arrayObj) << " array as argument 1 to "
+					<< pyutil::GridTraits<GridType>::name() << "." << methodName() << "()";
+				PyErr_SetString(PyExc_TypeError, os.str().c_str());
+				py::throw_error_already_set();
+			}
+		}
+	};
+
+	// Extract the list of mesh vertices from the arguments to this method.
+	std::vector<Vec3s> points;
+	if (!pointsObj.is_none()) {
+		// Extract a reference to (not a copy of) a NumPy array argument,
+		// or throw an exception if the argument is not a NumPy array object.
+		auto arrayObj = extractValueArg<GridType, NumPyArrayType>(
+			pointsObj, Local::methodName(), /*argIdx=*/1, "numpy.ndarray");
+
+		// Throw an exception if the array has the wrong type or dimensions.
+		Local::validate2DNumPyArray(arrayObj, /*N=*/3, /*desiredType=*/"float");
+
+		// Copy values from the array to the vector.
+		copyVecArray(arrayObj, points);
+	}
+
+	// Extract the transform from the arguments to this method.
+	math::Transform::Ptr xform = math::Transform::createLinearTransform();
+	if (!xformObj.is_none()) {
+		xform = extractValueArg<GridType, math::Transform::Ptr>(
+			xformObj, Local::methodName(), /*argIdx=*/2, "Transform");
+	}
+
+	const float radius = pyutil::extractArg<float>(
+		radiusObj, "pointsToLevelSet", /*className=*/nullptr, /*argIdx=*/3, "float");
+
+	openvdb::FloatGrid::Ptr outputGrid;
+
+	float background = xform->voxelSize()[0] * 2.0f; // / 8.0f;
+
+	outputGrid = openvdb::FloatGrid::create(background);
+	outputGrid->setGridClass(openvdb::GRID_LEVEL_SET);
+	outputGrid->setTransform(xform);
+
+	openvdb::tools::ParticlesToLevelSet<openvdb::FloatGrid, openvdb::Int32> raster(*outputGrid);
+
+	raster.setRmin(1.0f);
+	raster.setRmax(1e15f);
+
+	ParticleList paList(&points);
+
+	raster.rasterizeSpheres(paList, radius);
+
+	// always prune to produce a valid narrow-band level set.
+	raster.finalize(true);
+	
+	//openvdb::Int32Grid::Ptr closestPtnIdxGrid = raster.attributeGrid();
+
+	return outputGrid;
+}
+
+
+
+template<typename GridType>
+inline void
+smooth(GridType& grid,
+	py::object smoothvalueObj,
+	py::object widthObj)
+{
+	const int smooth = pyutil::extractArg<int>(
+		smoothvalueObj, "smooth", /*className=*/nullptr, /*argIdx=*/4, "int");
+
+	const int width = pyutil::extractArg<int>(
+		widthObj, "smooth", /*className=*/nullptr, /*argIdx=*/5, "int");
+
+	// Gaussian smoothing
+	openvdb::tools::Filter<GridType> filter(grid);
+	
+	if (smooth > 0) {
+		filter.gaussian(width, smooth);
+	}
+}
+
+
+template<typename GridType>
+inline void
+offset(GridType& grid,
+	py::object offsetObj)
+{
+    using ValueType = typename GridType::ValueType;
+	const float oset_val = pyutil::extractArg<float>(
+		offsetObj, "offset", /*className=*/nullptr, /*argIdx=*/1, "float");
+
+	// offset
+	openvdb::tools::Filter<GridType> filter(grid);
+	
+    filter.offset(static_cast<ValueType>(oset_val));
+}
+
+
+template<typename GridType>
+struct GaussianOp
+{
+    using ValueType = typename GridType::ValueType;
+    using TreeType = typename GridType::TreeType;
+    using Accessor = tree::ValueAccessor<const TreeType>;
+
+    GaussianOp(const TreeType& tree, int width, double sigma)
+        : mTreeAcc(tree), mWidth(width), mSigma(sigma) {}
+
+    int mWidth;
+    double mSigma;
+    Accessor mTreeAcc;
+
+    template <typename LeafNodeType>
+    void operator()(LeafNodeType &leaf, size_t) const
+    {
+        typename LeafNodeType::ValueOnIter iter = leaf.beginValueOn();
+        for (; iter; ++iter) {
+            ValueType total_sum = zeroVal<ValueType>();
+
+            for (int axis=0; axis<3; axis++) {
+                ValueType sum = zeroVal<ValueType>();
+                Coord xyz = iter.getCoord();
+
+                // Sampled Gaussian kernel
+                float multiplier = 0.f; //, error = 0.f;
+                int M = mWidth;
+
+                Int32 &i = xyz[axis], j = i + M;
+                Int32 center = i;
+                
+                for (i -= M; i <= j; ++i) {
+                    // G(x) = 1/sqrt(2*PI)/sigma * e ** -(x**2/(2*sigma**2))
+                    Int32 x = i - center;
+                    multiplier = 1.f / PISQRT / mSigma * std::pow(EE, -x*x / (2 * mSigma*mSigma));
+                    sum += multiplier * mTreeAcc.getValue(xyz);
+                }
+
+                total_sum += sum;
+            }
+
+            iter.setValue(total_sum/3);
+        }
+    }
+};
+
+
+template<typename GridT>
+inline void
+gaussianSmooth(GridT& grid,
+	py::object smoothvalueObj,
+	py::object widthObj)
+{
+    using GridType = GridT;
+    using TreeType = typename GridType::TreeType;
+    using LeafType = typename TreeType::LeafNodeType;
+    using ValueType = typename GridType::ValueType;
+    using LeafManagerType = typename tree::LeafManager<TreeType>;
+    using RangeType = typename LeafManagerType::LeafRange;
+    using BufferType = typename LeafManagerType::BufferType;
+    using ValueOnIterType = typename GridType::ValueOnIter;
+    using ValueOnCIterType = typename GridType::ValueOnCIter;
+    using ValueOffIterType = typename GridType::ValueOffIter;
+    using LeafCIterType = typename TreeType::LeafCIter;
+    // using IterRange = openvdb::tree::IteratorRange<typename TreeType::LeafCIter>;
+    using RangeType = typename LeafManagerType::LeafRange;
+
+
+	double sigma = pyutil::extractArg<double>(
+		smoothvalueObj, "gaussian", /*className=*/nullptr, /*argIdx=*/1, "double");
+
+	int width = pyutil::extractArg<int>(
+		widthObj, "gaussian", /*className=*/nullptr, /*argIdx=*/2, "int");
+
+
+    // sanity check
+    sigma = std::max(0.1, sigma);
+    width = std::min(width, 10);
+
+
+    # if 0
+
+    TreeType the_tree = grid.tree();
+    // separated 3 x 1D Gaussian kernel
+    for (ValueOnIterType iter = grid.beginValueOn(); iter; ++iter) {
+    // for (LeafCIterType iter = grid.tree().cbeginLeaf(); iter; ++iter) {
+        ValueType total_sum = zeroVal<ValueType>();
+
+        for (int axis=0; axis<3; axis++) {
+            ValueType sum = zeroVal<ValueType>();
+            Coord xyz = iter.getCoord();
+
+            // Sampled Gaussian kernel
+            float multiplier = 0.f; //, error = 0.f;
+            int M = width;
+
+            Int32 &i = xyz[axis], j = i + M;
+            Int32 center = i;
+            
+            for (i -= M; i <= j; ++i) {
+                // G(x) = 1/sqrt(2*PI)/sigma * e ** -(x**2/(2*sigma**2))
+                Int32 x = i - center;
+                multiplier = 1.f / PISQRT / sigma * std::pow(EE, -x*x / (2 * sigma*sigma));
+                sum += multiplier * the_tree.getValue(xyz);
+            }
+
+            total_sum += sum;
+        }
+
+        iter.setValue(total_sum/3);
+    }
+
+    # else
+
+    int grainsize = 1; // multithreading
+    LeafManagerType leafs(grid.tree(), 1, grainsize==0);
+
+    GaussianOp<GridType> proc(grid.tree(), width, sigma);
+
+    leafs.foreach(proc);
+
+    // tbb::parallel_for(leafs.leafRange(), proc);
+    // leafs.swapLeafBuffer(1, grainsize==0);
+
+    # endif
+}
+
+// template<typename GridType>
+// //inline void
+// inline typename GridType::Ptr
+// applyTransform(GridType& grid)
+// {
+//     // if (grid.transform().isLinear())  {
+//     openvdb::math::Transform::Ptr linearTransform =
+//         openvdb::math::Transform::createLinearTransform(mat);
+
+//     // typename GridType::Ptr gridB = grid.copy(CP_NEW);
+//     typename GridType::Ptr gridB = grid.deepCopy();
+//     gridB->setTransform(linearTransform);
+
+//     // tools::resampleToMatch<tools::PointSampler>(grid, *gridB);
+
+//     const openvdb::math::Transform
+//         &sourceXform = grid.transform(),
+//         &targetXform = gridB->transform();
+
+//     openvdb::Mat4R xform =
+//         sourceXform.baseMap()->getAffineMap()->getMat4() *
+//         targetXform.baseMap()->getAffineMap()->getMat4().inverse();
+
+//     openvdb::Mat4R xform = grid.transform().baseMap()->getAffineMap()->getMat4().inverse();
+
+//     openvdb::tools::GridTransformer transformer(xform);
+//     transformer.transformGrid<openvdb::tools::PointSampler, GridType>(grid, *gridB);
+
+//     gridB->tree().prune();
+
+//     return gridB;
+// }
+
+
+template<typename GridType>
+inline void
+csgIntersection(GridType& grid, py::object otherGridObj, bool resample)
+{
+    using GridPtr = typename GridType::Ptr;
+    GridPtr otherGrid = extractValueArg<GridType, GridPtr>(otherGridObj,
+        "intersection", 1, pyutil::GridTraits<GridType>::name());
+
+    if (resample) {
+        typename GridType::Ptr gridB = grid.deepCopy();
+        gridB->setTransform(grid.transform().copy());
+
+        tools::resampleToMatch<tools::PointSampler>(*otherGrid, *gridB);
+        openvdb::tools::csgIntersection(grid, *gridB);
+    } else {
+        openvdb::tools::csgIntersection(grid, *otherGrid);
+    }
+}
+
+template<typename GridType>
+inline void
+csgUnion(GridType& grid, py::object otherGridObj, bool resample)
+{
+    using GridPtr = typename GridType::Ptr;
+    GridPtr otherGrid = extractValueArg<GridType, GridPtr>(otherGridObj,
+        "union", 1, pyutil::GridTraits<GridType>::name());
+
+    if (resample) {
+        typename GridType::Ptr gridB = grid.deepCopy();
+        gridB->setTransform(grid.transform().copy());
+
+        tools::resampleToMatch<tools::PointSampler>(*otherGrid, *gridB);
+        openvdb::tools::csgUnion(grid, *gridB);
+    } else {
+        openvdb::tools::csgUnion(grid, *otherGrid);
+    }
+
+}
+
+template<typename GridType>
+inline void
+csgDifference(GridType& grid, py::object otherGridObj, bool resample)
+{
+    using GridPtr = typename GridType::Ptr;
+    GridPtr otherGrid = extractValueArg<GridType, GridPtr>(otherGridObj,
+        "difference", 1, pyutil::GridTraits<GridType>::name());
+
+    if (resample) {
+        typename GridType::Ptr gridB = grid.deepCopy();
+        gridB->setTransform(grid.transform().copy());
+
+        tools::resampleToMatch<tools::PointSampler>(*otherGrid, *gridB);
+        openvdb::tools::csgDifference(grid, *gridB);
+    } else {
+        openvdb::tools::csgDifference(grid, *otherGrid);
+    }
+}
+
+
+
+// amb: end
+
+
 template<typename GridType>
 inline py::object
 volumeToQuadMesh(const GridType& grid, py::object isovalueObj)
@@ -2376,6 +2879,33 @@ exportGrid()
                 + "-dimensional array with values\n"
                 "from this grid, starting at voxel (i, j, k).").c_str())
 
+            .def("smooth", &pyGrid::smooth<GridType>, 
+                (py::arg("smooth") = 0, py::arg("width") = 1),
+                "Normal smoothing")
+
+            .def("offset", &pyGrid::offset<GridType>, 
+                (py::arg("offset") = 0.0),
+                "Surface offset")
+
+            .def("gaussian", &pyGrid::gaussianSmooth<GridType>, 
+                (py::arg("sigma") = 1.0, py::arg("width") = 1),
+                "Gaussian smoothing")
+
+            // .def("applyTransform", &pyGrid::applyTransform<GridType>, 
+            //     "Apply transform, resample VDB data")
+
+            .def("intersection", &pyGrid::csgIntersection<GridType>, 
+                (py::arg("grid"), py::arg("resample")=false),
+                "CSG Intersection")
+
+            .def("union", &pyGrid::csgUnion<GridType>, 
+                (py::arg("grid"), py::arg("resample")=false),
+                "CSG Union")
+
+            .def("difference", &pyGrid::csgDifference<GridType>, 
+                (py::arg("grid"), py::arg("resample")=false),
+                "CSG Difference")
+
             .def("convertToQuads",
                 &pyGrid::volumeToQuadMesh<GridType>,
                 (py::arg("isovalue")=0),
@@ -2396,6 +2926,16 @@ exportGrid()
                 "produces a high-polygon-count mesh that closely approximates\n"
                 "the isosurface, and 1 produces a lower-polygon-count mesh\n"
                 "with some loss of surface detail.")
+
+			.def("createLevelSetFromPoints",
+				&pyGrid::pointsToLevelSet<GridType>,
+				(py::arg("points"),
+					py::arg("transform")=py::object(),
+					py::arg("radius")=py::object()
+					//py::arg("size") = 1.0f
+					),
+				"(TBD) points, transform, radius")
+
             .def("createLevelSetFromPolygons",
                 &pyGrid::meshToLevelSet<GridType>,
                 (py::arg("points"),
diff --git a/openvdb/python/pyOpenVDBModule.cc b/openvdb/python/pyOpenVDBModule.cc
index c930fd9..f6bd06b 100644
--- a/openvdb/python/pyOpenVDBModule.cc
+++ b/openvdb/python/pyOpenVDBModule.cc
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -304,9 +304,8 @@ struct MetaMapConverter
             py::object val = pyDict[keys[i]];
             Metadata::Ptr value;
             if (py::extract<std::string>(val).check()) {
-                value.reset(
-                    new StringMetadata(py::extract<std::string>(val)));
-            } else if (PyBool_Check(val.ptr())) {
+                value.reset(new StringMetadata(py::extract<std::string>(val)));
+            } else if (bool(PyBool_Check(val.ptr()))) {
                 value.reset(new BoolMetadata(py::extract<bool>(val)));
             } else if (py::extract<Int64>(val).check()) {
                 const Int64 n = py::extract<Int64>(val);
@@ -806,6 +805,6 @@ BOOST_PYTHON_MODULE(PY_OPENVDB_MODULE_NAME)
 
 } // BOOST_PYTHON_MODULE
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
